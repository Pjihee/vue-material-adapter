{"version":3,"sources":["webpack:///./packages/mcwv-dialog/node_modules/tabbable/index.js","webpack:///./packages/mcwv-drawer/node_modules/tabbable/index.js"],"names":["candidateSelectors","candidateSelector","join","matches","Element","prototype","msMatchesSelector","webkitMatchesSelector","tabbable","el","options","i","candidate","candidateTabindex","regularTabbables","orderedTabbables","candidates","querySelectorAll","includeContainer","call","Array","slice","apply","unshift","length","isNodeMatchingSelectorTabbable","getTabindex","push","documentOrder","tabIndex","node","sort","sortOrderedTabbables","map","a","concat","isNodeMatchingSelectorFocusable","isInput","type","isRadio","name","checked","nodes","getCheckedRadio","ownerDocument","isTabbableRadio","isNonTabbableRadio","disabled","isHiddenInput","offsetParent","getComputedStyle","visibility","isHidden","isTabbable","Error","isFocusable","focusableCandidateSelector","tabindexAttr","parseInt","getAttribute","isNaN","contentEditable","isContentEditable","b","tagName","module","exports"],"mappings":"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","file":"npm.tabbable.a2ab1b72a447de3abf1e.js","sourcesContent":["var candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n];\nvar candidateSelector = candidateSelectors.join(',');\n\nvar matches = typeof Element === 'undefined'\n  ? function () {}\n  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  var regularTabbables = [];\n  var orderedTabbables = [];\n\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate)) continue;\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map(function(a) { return a.node })\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (\n    !isNodeMatchingSelectorFocusable(node)\n    || isNonTabbableRadio(node)\n    || getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (\n    node.disabled\n    || isHiddenInput(node)\n    || isHidden(node)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr;\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true;\n  // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';\n}\n\nmodule.exports = tabbable;\n","var candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n];\nvar candidateSelector = candidateSelectors.join(',');\n\nvar matches = typeof Element === 'undefined'\n  ? function () {}\n  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  var regularTabbables = [];\n  var orderedTabbables = [];\n\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate)) continue;\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map(function(a) { return a.node })\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (\n    !isNodeMatchingSelectorFocusable(node)\n    || isNonTabbableRadio(node)\n    || getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (\n    node.disabled\n    || isHiddenInput(node)\n    || isHidden(node)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr;\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true;\n  // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';\n}\n\nmodule.exports = tabbable;\n"],"sourceRoot":""}