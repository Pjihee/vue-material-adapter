{"version":3,"sources":["webpack:///./packages/mcwv-dialog/node_modules/focus-trap/index.js","webpack:///./packages/mcwv-drawer/node_modules/focus-trap/index.js"],"names":["trapQueue","tabbable","__webpack_require__","xtend","activeFocusTraps","activateTrap","trap","length","activeTrap","pause","trapIndex","indexOf","push","splice","deactivateTrap","unpause","delay","fn","setTimeout","module","exports","element","userOptions","doc","document","container","querySelector","config","returnFocusOnDeactivate","escapeDeactivates","state","firstTabbableNode","lastTabbableNode","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","activate","activateOptions","updateTabbableNodes","activeElement","onActivate","addListeners","deactivate","removeListeners","deactivateOptions","onDeactivate","undefined","returnFocus","tryFocus","getInitialFocusNode","addEventListener","checkFocusIn","checkPointerDown","capture","passive","checkClick","checkKey","removeEventListener","getNodeForOption","optionName","optionValue","node","Error","contains","e","target","clickOutsideDeactivates","isFocusable","preventDefault","Document","stopImmediatePropagation","key","keyCode","isEscapeEvent","isTabEvent","shiftKey","checkTab","tabbableNodes","focus","tagName","toLowerCase","select","isSelectableInput"],"mappings":"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","file":"npm.focus-trap.a0e32d9c1c541cab43bd.js","sourcesContent":["var tabbable = require('tabbable');\nvar xtend = require('xtend');\n\nvar activeFocusTraps = (function() {\n  var trapQueue = [];\n  return {\n    activateTrap: function(trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n\n    deactivateTrap: function(trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    }\n  };\n})();\n\nfunction focusTrap(element, userOptions) {\n  var doc = document;\n  var container =\n    typeof element === 'string' ? doc.querySelector(element) : element;\n\n  var config = xtend(\n    {\n      returnFocusOnDeactivate: true,\n      escapeDeactivates: true\n    },\n    userOptions\n  );\n\n  var state = {\n    firstTabbableNode: null,\n    lastTabbableNode: null,\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false\n  };\n\n  var trap = {\n    activate: activate,\n    deactivate: deactivate,\n    pause: pause,\n    unpause: unpause\n  };\n\n  return trap;\n\n  function activate(activateOptions) {\n    if (state.active) return;\n\n    updateTabbableNodes();\n\n    state.active = true;\n    state.paused = false;\n    state.nodeFocusedBeforeActivation = doc.activeElement;\n\n    var onActivate =\n      activateOptions && activateOptions.onActivate\n        ? activateOptions.onActivate\n        : config.onActivate;\n    if (onActivate) {\n      onActivate();\n    }\n\n    addListeners();\n    return trap;\n  }\n\n  function deactivate(deactivateOptions) {\n    if (!state.active) return;\n\n    removeListeners();\n    state.active = false;\n    state.paused = false;\n\n    activeFocusTraps.deactivateTrap(trap);\n\n    var onDeactivate =\n      deactivateOptions && deactivateOptions.onDeactivate !== undefined\n        ? deactivateOptions.onDeactivate\n        : config.onDeactivate;\n    if (onDeactivate) {\n      onDeactivate();\n    }\n\n    var returnFocus =\n      deactivateOptions && deactivateOptions.returnFocus !== undefined\n        ? deactivateOptions.returnFocus\n        : config.returnFocusOnDeactivate;\n    if (returnFocus) {\n      delay(function() {\n        tryFocus(state.nodeFocusedBeforeActivation);\n      });\n    }\n\n    return trap;\n  }\n\n  function pause() {\n    if (state.paused || !state.active) return;\n    state.paused = true;\n    removeListeners();\n  }\n\n  function unpause() {\n    if (!state.paused || !state.active) return;\n    state.paused = false;\n    updateTabbableNodes();\n    addListeners();\n  }\n\n  function addListeners() {\n    if (!state.active) return;\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    delay(function() {\n      tryFocus(getInitialFocusNode());\n    });\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n\n    return trap;\n  }\n\n  function removeListeners() {\n    if (!state.active) return;\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n\n    return trap;\n  }\n\n  function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    var node = optionValue;\n    if (!optionValue) {\n      return null;\n    }\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue);\n      if (!node) {\n        throw new Error('`' + optionName + '` refers to no known node');\n      }\n    }\n    if (typeof optionValue === 'function') {\n      node = optionValue();\n      if (!node) {\n        throw new Error('`' + optionName + '` did not return a node');\n      }\n    }\n    return node;\n  }\n\n  function getInitialFocusNode() {\n    var node;\n    if (getNodeForOption('initialFocus') !== null) {\n      node = getNodeForOption('initialFocus');\n    } else if (container.contains(doc.activeElement)) {\n      node = doc.activeElement;\n    } else {\n      node = state.firstTabbableNode || getNodeForOption('fallbackFocus');\n    }\n\n    if (!node) {\n      throw new Error(\n        \"You can't have a focus-trap without at least one focusable element\"\n      );\n    }\n\n    return node;\n  }\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  function checkPointerDown(e) {\n    if (container.contains(e.target)) return;\n    if (config.clickOutsideDeactivates) {\n      deactivate({\n        returnFocus: !tabbable.isFocusable(e.target)\n      });\n    } else {\n      e.preventDefault();\n    }\n  }\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  function checkFocusIn(e) {\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (container.contains(e.target) || e.target instanceof Document) {\n      return;\n    }\n    e.stopImmediatePropagation();\n    tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n  }\n\n  function checkKey(e) {\n    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {\n      e.preventDefault();\n      deactivate();\n      return;\n    }\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  }\n\n  // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  function checkTab(e) {\n    updateTabbableNodes();\n    if (e.shiftKey && e.target === state.firstTabbableNode) {\n      e.preventDefault();\n      tryFocus(state.lastTabbableNode);\n      return;\n    }\n    if (!e.shiftKey && e.target === state.lastTabbableNode) {\n      e.preventDefault();\n      tryFocus(state.firstTabbableNode);\n      return;\n    }\n  }\n\n  function checkClick(e) {\n    if (config.clickOutsideDeactivates) return;\n    if (container.contains(e.target)) return;\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }\n\n  function updateTabbableNodes() {\n    var tabbableNodes = tabbable(container);\n    state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();\n    state.lastTabbableNode =\n      tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();\n  }\n\n  function tryFocus(node) {\n    if (node === doc.activeElement) return;\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus();\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  }\n}\n\nfunction isSelectableInput(node) {\n  return (\n    node.tagName &&\n    node.tagName.toLowerCase() === 'input' &&\n    typeof node.select === 'function'\n  );\n}\n\nfunction isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n}\n\nfunction isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n}\n\nfunction delay(fn) {\n  return setTimeout(fn, 0);\n}\n\nmodule.exports = focusTrap;\n","var tabbable = require('tabbable');\nvar xtend = require('xtend');\n\nvar activeFocusTraps = (function() {\n  var trapQueue = [];\n  return {\n    activateTrap: function(trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n\n    deactivateTrap: function(trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    }\n  };\n})();\n\nfunction focusTrap(element, userOptions) {\n  var doc = document;\n  var container =\n    typeof element === 'string' ? doc.querySelector(element) : element;\n\n  var config = xtend(\n    {\n      returnFocusOnDeactivate: true,\n      escapeDeactivates: true\n    },\n    userOptions\n  );\n\n  var state = {\n    firstTabbableNode: null,\n    lastTabbableNode: null,\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false\n  };\n\n  var trap = {\n    activate: activate,\n    deactivate: deactivate,\n    pause: pause,\n    unpause: unpause\n  };\n\n  return trap;\n\n  function activate(activateOptions) {\n    if (state.active) return;\n\n    updateTabbableNodes();\n\n    state.active = true;\n    state.paused = false;\n    state.nodeFocusedBeforeActivation = doc.activeElement;\n\n    var onActivate =\n      activateOptions && activateOptions.onActivate\n        ? activateOptions.onActivate\n        : config.onActivate;\n    if (onActivate) {\n      onActivate();\n    }\n\n    addListeners();\n    return trap;\n  }\n\n  function deactivate(deactivateOptions) {\n    if (!state.active) return;\n\n    removeListeners();\n    state.active = false;\n    state.paused = false;\n\n    activeFocusTraps.deactivateTrap(trap);\n\n    var onDeactivate =\n      deactivateOptions && deactivateOptions.onDeactivate !== undefined\n        ? deactivateOptions.onDeactivate\n        : config.onDeactivate;\n    if (onDeactivate) {\n      onDeactivate();\n    }\n\n    var returnFocus =\n      deactivateOptions && deactivateOptions.returnFocus !== undefined\n        ? deactivateOptions.returnFocus\n        : config.returnFocusOnDeactivate;\n    if (returnFocus) {\n      delay(function() {\n        tryFocus(state.nodeFocusedBeforeActivation);\n      });\n    }\n\n    return trap;\n  }\n\n  function pause() {\n    if (state.paused || !state.active) return;\n    state.paused = true;\n    removeListeners();\n  }\n\n  function unpause() {\n    if (!state.paused || !state.active) return;\n    state.paused = false;\n    updateTabbableNodes();\n    addListeners();\n  }\n\n  function addListeners() {\n    if (!state.active) return;\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    delay(function() {\n      tryFocus(getInitialFocusNode());\n    });\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n\n    return trap;\n  }\n\n  function removeListeners() {\n    if (!state.active) return;\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n\n    return trap;\n  }\n\n  function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    var node = optionValue;\n    if (!optionValue) {\n      return null;\n    }\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue);\n      if (!node) {\n        throw new Error('`' + optionName + '` refers to no known node');\n      }\n    }\n    if (typeof optionValue === 'function') {\n      node = optionValue();\n      if (!node) {\n        throw new Error('`' + optionName + '` did not return a node');\n      }\n    }\n    return node;\n  }\n\n  function getInitialFocusNode() {\n    var node;\n    if (getNodeForOption('initialFocus') !== null) {\n      node = getNodeForOption('initialFocus');\n    } else if (container.contains(doc.activeElement)) {\n      node = doc.activeElement;\n    } else {\n      node = state.firstTabbableNode || getNodeForOption('fallbackFocus');\n    }\n\n    if (!node) {\n      throw new Error(\n        \"You can't have a focus-trap without at least one focusable element\"\n      );\n    }\n\n    return node;\n  }\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  function checkPointerDown(e) {\n    if (container.contains(e.target)) return;\n    if (config.clickOutsideDeactivates) {\n      deactivate({\n        returnFocus: !tabbable.isFocusable(e.target)\n      });\n    } else {\n      e.preventDefault();\n    }\n  }\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  function checkFocusIn(e) {\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (container.contains(e.target) || e.target instanceof Document) {\n      return;\n    }\n    e.stopImmediatePropagation();\n    tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n  }\n\n  function checkKey(e) {\n    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {\n      e.preventDefault();\n      deactivate();\n      return;\n    }\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  }\n\n  // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  function checkTab(e) {\n    updateTabbableNodes();\n    if (e.shiftKey && e.target === state.firstTabbableNode) {\n      e.preventDefault();\n      tryFocus(state.lastTabbableNode);\n      return;\n    }\n    if (!e.shiftKey && e.target === state.lastTabbableNode) {\n      e.preventDefault();\n      tryFocus(state.firstTabbableNode);\n      return;\n    }\n  }\n\n  function checkClick(e) {\n    if (config.clickOutsideDeactivates) return;\n    if (container.contains(e.target)) return;\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }\n\n  function updateTabbableNodes() {\n    var tabbableNodes = tabbable(container);\n    state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();\n    state.lastTabbableNode =\n      tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();\n  }\n\n  function tryFocus(node) {\n    if (node === doc.activeElement) return;\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus();\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  }\n}\n\nfunction isSelectableInput(node) {\n  return (\n    node.tagName &&\n    node.tagName.toLowerCase() === 'input' &&\n    typeof node.select === 'function'\n  );\n}\n\nfunction isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n}\n\nfunction isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n}\n\nfunction delay(fn) {\n  return setTimeout(fn, 0);\n}\n\nmodule.exports = focusTrap;\n"],"sourceRoot":""}