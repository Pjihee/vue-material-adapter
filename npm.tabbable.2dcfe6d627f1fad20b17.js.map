{"version":3,"sources":["webpack:///./packages/mcwv-dialog/node_modules/tabbable/index.js","webpack:///./packages/mcwv-drawer/node_modules/tabbable/index.js"],"names":["candidateSelectors","candidateSelector","join","matches","Element","prototype","msMatchesSelector","webkitMatchesSelector","tabbable","el","options","i","candidate","candidateTabindex","regularTabbables","orderedTabbables","untouchabilityChecker","UntouchabilityChecker","ownerDocument","candidates","querySelectorAll","includeContainer","call","Array","slice","apply","unshift","length","isNodeMatchingSelectorTabbable","getTabindex","push","documentOrder","tabIndex","node","sort","sortOrderedTabbables","map","a","concat","isNodeMatchingSelectorFocusable","isInput","type","isRadio","name","checked","nodes","getCheckedRadio","isTabbableRadio","isNonTabbableRadio","disabled","isHiddenInput","isUntouchable","isTabbable","Error","isFocusable","focusableCandidateSelector","tabindexAttr","parseInt","getAttribute","isNaN","contentEditable","isContentEditable","b","tagName","elementDocument","this","doc","cache","hasDisplayNone","nodeComputedStyle","nodeType","Node","ELEMENT_NODE","cached","list","predicate","find","item","result","defaultView","getComputedStyle","display","parentNode","documentElement","computedStyle","visibility","module","exports"],"mappings":"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","file":"npm.tabbable.2dcfe6d627f1fad20b17.js","sourcesContent":["var candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n];\nvar candidateSelector = candidateSelectors.join(',');\n\nvar matches = typeof Element === 'undefined'\n  ? function () {}\n  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  var elementDocument = el.ownerDocument || el;\n  var regularTabbables = [];\n  var orderedTabbables = [];\n\n  var untouchabilityChecker = new UntouchabilityChecker(elementDocument);\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate, untouchabilityChecker)) continue;\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map(function(a) { return a.node })\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node, untouchabilityChecker) {\n  if (\n    !isNodeMatchingSelectorFocusable(node, untouchabilityChecker)\n    || isNonTabbableRadio(node)\n    || getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node, untouchabilityChecker) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node, untouchabilityChecker);\n}\n\nfunction isNodeMatchingSelectorFocusable(node, untouchabilityChecker) {\n  untouchabilityChecker = untouchabilityChecker || new UntouchabilityChecker(node.ownerDocument || node);\n  if (\n    node.disabled\n    || isHiddenInput(node)\n    || untouchabilityChecker.isUntouchable(node)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node, untouchabilityChecker) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node, untouchabilityChecker);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr;\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\n// Array.prototype.find not available in IE.\nfunction find(list, predicate) {\n  for (var i = 0, length = list.length; i < length; i++) {\n    if (predicate(list[i])) return list[i];\n  }\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true;\n  // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n}\n\n// An element is \"untouchable\" if *it or one of its ancestors* has\n// `visibility: hidden` or `display: none`.\nfunction UntouchabilityChecker(elementDocument) {\n  this.doc = elementDocument;\n  // Node cache must be refreshed on every check, in case\n  // the content of the element has changed. The cache contains tuples\n  // mapping nodes to their boolean result.\n  this.cache = [];\n}\n\n// getComputedStyle accurately reflects `visibility: hidden` of ancestors\n// but not `display: none`, so we need to recursively check parents.\nUntouchabilityChecker.prototype.hasDisplayNone = function hasDisplayNone(node, nodeComputedStyle) {\n  if (node.nodeType !== Node.ELEMENT_NODE) return false;\n\n    // Search for a cached result.\n    var cached = find(this.cache, function(item) {\n      return item === node;\n    });\n    if (cached) return cached[1];\n\n    nodeComputedStyle = nodeComputedStyle || this.doc.defaultView.getComputedStyle(node);\n\n    var result = false;\n\n    if (nodeComputedStyle.display === 'none') {\n      result = true;\n    } else if (node.parentNode) {\n      result = this.hasDisplayNone(node.parentNode);\n    }\n\n    this.cache.push([node, result]);\n\n    return result;\n}\n\nUntouchabilityChecker.prototype.isUntouchable = function isUntouchable(node) {\n  if (node === this.doc.documentElement) return false;\n  var computedStyle = this.doc.defaultView.getComputedStyle(node);\n  if (this.hasDisplayNone(node, computedStyle)) return true;\n  return computedStyle.visibility === 'hidden';\n}\n\nmodule.exports = tabbable;\n","var candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n];\nvar candidateSelector = candidateSelectors.join(',');\n\nvar matches = typeof Element === 'undefined'\n  ? function () {}\n  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  var elementDocument = el.ownerDocument || el;\n  var regularTabbables = [];\n  var orderedTabbables = [];\n\n  var untouchabilityChecker = new UntouchabilityChecker(elementDocument);\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate, untouchabilityChecker)) continue;\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map(function(a) { return a.node })\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node, untouchabilityChecker) {\n  if (\n    !isNodeMatchingSelectorFocusable(node, untouchabilityChecker)\n    || isNonTabbableRadio(node)\n    || getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node, untouchabilityChecker) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node, untouchabilityChecker);\n}\n\nfunction isNodeMatchingSelectorFocusable(node, untouchabilityChecker) {\n  untouchabilityChecker = untouchabilityChecker || new UntouchabilityChecker(node.ownerDocument || node);\n  if (\n    node.disabled\n    || isHiddenInput(node)\n    || untouchabilityChecker.isUntouchable(node)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node, untouchabilityChecker) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node, untouchabilityChecker);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr;\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\n// Array.prototype.find not available in IE.\nfunction find(list, predicate) {\n  for (var i = 0, length = list.length; i < length; i++) {\n    if (predicate(list[i])) return list[i];\n  }\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true;\n  // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n}\n\n// An element is \"untouchable\" if *it or one of its ancestors* has\n// `visibility: hidden` or `display: none`.\nfunction UntouchabilityChecker(elementDocument) {\n  this.doc = elementDocument;\n  // Node cache must be refreshed on every check, in case\n  // the content of the element has changed. The cache contains tuples\n  // mapping nodes to their boolean result.\n  this.cache = [];\n}\n\n// getComputedStyle accurately reflects `visibility: hidden` of ancestors\n// but not `display: none`, so we need to recursively check parents.\nUntouchabilityChecker.prototype.hasDisplayNone = function hasDisplayNone(node, nodeComputedStyle) {\n  if (node.nodeType !== Node.ELEMENT_NODE) return false;\n\n    // Search for a cached result.\n    var cached = find(this.cache, function(item) {\n      return item === node;\n    });\n    if (cached) return cached[1];\n\n    nodeComputedStyle = nodeComputedStyle || this.doc.defaultView.getComputedStyle(node);\n\n    var result = false;\n\n    if (nodeComputedStyle.display === 'none') {\n      result = true;\n    } else if (node.parentNode) {\n      result = this.hasDisplayNone(node.parentNode);\n    }\n\n    this.cache.push([node, result]);\n\n    return result;\n}\n\nUntouchabilityChecker.prototype.isUntouchable = function isUntouchable(node) {\n  if (node === this.doc.documentElement) return false;\n  var computedStyle = this.doc.defaultView.getComputedStyle(node);\n  if (this.hasDisplayNone(node, computedStyle)) return true;\n  return computedStyle.visibility === 'hidden';\n}\n\nmodule.exports = tabbable;\n"],"sourceRoot":""}